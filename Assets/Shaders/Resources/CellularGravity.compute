
#define GROUPSIZE 128

//////////////////////////////////////////////////////////////////////////////////////

struct Cell
{
    float  mass;
	float2 vel;
	float2 pos;		
	float2 force;
};

struct RowStats
{
    float maxMass;
    float maxVel;
};

RWStructuredBuffer<Cell> inCellBuffer;
RWStructuredBuffer<Cell> outCellBuffer;
RWStructuredBuffer<Cell> inOutCellBuffer;
RWStructuredBuffer<RowStats> outRowStatsBuffer;
RWStructuredBuffer<float> inMassSATBuffer;
RWStructuredBuffer<float> outMassSATBuffer;
RWStructuredBuffer<float> inOutMassSATBuffer;
RWTexture2D<half4> renderTexture; 

float gravity;
float cellSize;
float cellArea;
float deltaTime;
float density;
int width;
int height;

//////////////////////////////////////////////////////////////////////////////////////

float CellOffsetArea(float2 pos, float2 offset)
{
    float cellExtents = cellSize / 2;

    float infX = pos.x - cellExtents;
    float infY = pos.y - cellExtents;
    float supX = pos.x + cellExtents;
    float supY = pos.y + cellExtents;
        
    return (supX - infX) * abs(offset.y) + (supY - infY) * abs(offset.x) - abs(offset.x * offset.y);
}
    
float CellOverlappingArea(float2 pos0, float2 pos1, float cellSize)
{
    float cellExtents = cellSize / 2;
        
    float left1 = pos0.x - cellExtents;
    float right1 = pos0.x + cellExtents;
    float top1 = pos0.y + cellExtents;
    float bottom1 = pos0.y - cellExtents;
		
    float left2 = pos1.x - cellExtents;
    float right2 = pos1.x + cellExtents;
    float top2 = pos1.y + cellExtents;
    float bottom2 = pos1.y - cellExtents;
		
    float xOverlap = max(0, min(right1, right2) - max(left1, left2));
    float yOverlap = max(0, min(top1, top2) - max(bottom1, bottom2));
    return xOverlap * yOverlap;
 }
 
float CellOverlappingArea(float2 pos0, float2 pos1, float cellSize0, float cellSize1)
{
    float cellExtents0 = cellSize0 / 2;
    float cellExtents1 = cellSize1 / 2;
        
    float left1 = pos0.x - cellExtents0;
    float right1 = pos0.x + cellExtents0;
    float top1 = pos0.y + cellExtents0;
    float bottom1 = pos0.y - cellExtents0;
		
    float left2 = pos1.x - cellExtents1;
    float right2 = pos1.x + cellExtents1;
    float top2 = pos1.y + cellExtents1;
    float bottom2 = pos1.y - cellExtents1;
		
    float xOverlap = max(0, min(right1, right2) - max(left1, left2));
    float yOverlap = max(0, min(top1, top2) - max(bottom1, bottom2));
    return xOverlap * yOverlap;
 } 
 
 float2 GravityForce(float2 p0, float m0, float2 p1, float m1)
 {
    float2 dir = p1 - p0;
    float r = length(dir);
    if (r > 0)
    {
        dir *= 1.0f / r;
        return dir * (m0 * m1 * gravity / ( r * r ));
    }
    else
    {
        return float2( 0, 0 );
    } 
}

float Angle(float2 from, float2 to)
{
    float fromSqrMag = from.x*from.x + from.y*from.y;
    float toSqrMag = to.x*to.x + to.y*to.y;

    float num = sqrt( fromSqrMag * toSqrMag);
    if ( num < 5.96E-08 )
    {
        return 0.0f;
    }
    return acos( clamp( dot(from, to) / num, -1.0, 1.0) ) * 57.29578;
}

float Angle360(float2 from, float2 to)
{
    float signedAngle = Angle(from, to) * sign( from.x * to.y - from.y * to.x);
    if( signedAngle < 0 )
    {
        return 360 + signedAngle;
    }
    else
    {
        return signedAngle;
    }
}

float3 HSV2RGB(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeGravityForceWithSAT

[numthreads(GROUPSIZE,1,1)]
void ComputeGravityForceWithSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width * height;
    
    if( i < length0 )
    {     
        int width0 = width;
        int height0 = height;
                     
        int y0 = i / width0;
        int x0 = i - y0 * width0;

        float2 p0 = inOutCellBuffer[i].pos;
        float m0 = inOutCellBuffer[i].mass;

        float2 force = float2( 0, 0 );
                        
        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++)
            {
                if ( !(dy0 == 0 && dx0 == 0) )
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                        
                    if (x1 >= 0 && x1 < width0 && y1 >= 0 && y1 < height0)
                    {
                        int j = y1 * width0 + x1;
                        
                        float2 p1 = inOutCellBuffer[j].pos;
                        float m1 = inOutCellBuffer[j].mass;
                        force += GravityForce( p0, m0, p1, m1 );
                    }                        
                }
            }
        }
        
        int offset = 3;
        while( offset <= max(width,height) )
        {
            int halfOffset = offset / 2;
        
            for (int dy0 = -1; dy0 <= 1; dy0++)
            {
                for (int dx0 = -1; dx0 <= 1; dx0++)
                {
                    if ( !(dy0 == 0 && dx0 == 0) )
                    {
                        int y1 = y0 + dy0 * offset;
                        int x1 = x0 + dx0 * offset;
                        
                        int yTop = max( 0, y1 - halfOffset - 1 );
                        int xLeft = max( 0, x1 - halfOffset - 1 );                        
                        int yBottom = min( height0 - 1, y1 + halfOffset );
                        int xRight = min( width0 - 1, x1 + halfOffset );
                        
                        if( yTop < yBottom && xLeft < xRight )
                        {
                            int ilt = yTop * width0 + xLeft;
                            int irt = yTop * width0 + xRight;
                            int irb = yBottom * width0 + xRight;
                            int ilb = yBottom * width0 + xLeft;
                            
                            float2 virtualCellPos = ( inOutCellBuffer[ilt].pos +
                                                      inOutCellBuffer[irt].pos +
                                                      inOutCellBuffer[irb].pos +
                                                      inOutCellBuffer[ilb].pos ) / 4;
                                                    
                            float2 virtualCellMass = inOutMassSATBuffer[irb] -
                                                     inOutMassSATBuffer[ilb] -
                                                     inOutMassSATBuffer[irt] +
                                                     inOutMassSATBuffer[ilt];
                                                     
                            force += GravityForce( p0, m0, virtualCellPos, virtualCellMass );                                                   
                        }
                    }
                }
            }
            
            offset *= 3;
        }
                
        inOutCellBuffer[i].force = force;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel IntegrateVelocity

[numthreads(GROUPSIZE,1,1)]
void IntegrateVelocity(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);  
    
    if( i < width*height )
    {    
        if (inOutCellBuffer[i].mass > 0)
        {
            inOutCellBuffer[i].vel += inOutCellBuffer[i].force / inOutCellBuffer[i].mass * deltaTime; 
        }
        else
        {
            inOutCellBuffer[i].vel = float2( 0, 0 ); 
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel MomentumTransfer

[numthreads(GROUPSIZE,1,1)]
void MomentumTransfer(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width*height; 
        
    if( i < length0 )
    {        
        float cellArea = cellSize * cellSize;
        
        int y0 = i / width;
        int x0 = i - y0 * width;
 
        outCellBuffer[i].pos = inCellBuffer[i].pos;
        outCellBuffer[i].force = inCellBuffer[i].force;

        float2 iOffset = inCellBuffer[i].vel * deltaTime;
        float offsetAreaRatio = CellOffsetArea( inCellBuffer[i].pos, iOffset) / cellArea;
        outCellBuffer[i].mass = inCellBuffer[i].mass - inCellBuffer[i].mass * offsetAreaRatio;
        
        if (outCellBuffer[i].mass < 0)
        {
            outCellBuffer[i].mass = 0;
        }
                    
        outCellBuffer[i].vel = inCellBuffer[i].vel * outCellBuffer[i].mass;      

        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++)
            {
                if (!(dy0 == 0 && dx0 == 0))
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                    
                    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height)
                    {
                        int j = y1 * width + x1;
                    
                        float2 jOffset = inCellBuffer[j].vel * deltaTime;
                        float overlappingArea = CellOverlappingArea( inCellBuffer[i].pos, inCellBuffer[j].pos + jOffset, cellSize);
                        if (overlappingArea > 0)
                        {
                            float overlappingAreaRatio = overlappingArea / cellArea;                             
                            float dm = inCellBuffer[j].mass * overlappingAreaRatio;                            
                            outCellBuffer[i].mass += dm;
                            outCellBuffer[i].vel += inCellBuffer[j].vel * dm;                                
                        }                        
                    }
                }
            }
        }
            
        if (outCellBuffer[i].mass > 0 )
        {
            outCellBuffer[i].vel = outCellBuffer[i].vel / outCellBuffer[i].mass;              
        }
        else
        {
            outCellBuffer[i].vel = float2( 0, 0 );
        }
    }
    else
    {
        outCellBuffer[i].force = inCellBuffer[i].force;
        outCellBuffer[i].mass = inCellBuffer[i].mass;
        outCellBuffer[i].vel = inCellBuffer[i].vel;
	    outCellBuffer[i].pos = inCellBuffer[i].pos;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel LocalExpansion

[numthreads(GROUPSIZE,1,1)]
void LocalExpansion(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width*height; 
        
    if( i < length0 )
    {
        float cellArea = cellSize * cellSize;
        
        int y0 = i / width;
        int x0 = i - y0 * width;
        
        float expansionVel = inCellBuffer[i].mass * density / cellArea;         
        float expandedCellSize = cellSize + expansionVel * deltaTime;
        float expandedCellArea = expandedCellSize * expandedCellSize;
        
        outCellBuffer[i].mass = inCellBuffer[i].mass * cellArea / expandedCellArea;
        outCellBuffer[i].vel = inCellBuffer[i].vel * outCellBuffer[i].mass;  
        
        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++) 
            {
                if (!(dy0 == 0 && dx0 == 0))
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                    
                    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height)
                    {
                        int j = y1 * width + x1;
                        
                        expansionVel = inCellBuffer[j].mass * density / cellArea;         
                        expandedCellSize = cellSize + expansionVel * deltaTime;
                        expandedCellArea = expandedCellSize * expandedCellSize;
                        
                        float overlappingArea = CellOverlappingArea( inCellBuffer[i].pos, inCellBuffer[j].pos, cellSize, expandedCellSize);
                        if( overlappingArea > 0 )
                        {
                            float overlappingAreaRatio = overlappingArea / expandedCellArea;
                            float dm = inCellBuffer[j].mass * overlappingAreaRatio;
                            outCellBuffer[i].mass += dm;
                            float2 expVel = outCellBuffer[j].vel;// + normalize( inCellBuffer[i].pos - inCellBuffer[j].pos ) * expansionVel;
                            outCellBuffer[i].vel += expVel * dm;     
                        }
                    }
                }
            }
        }
        
        if (outCellBuffer[i].mass > 0 )
        {
            outCellBuffer[i].vel = outCellBuffer[i].vel / outCellBuffer[i].mass;              
        }
        else
        {
            outCellBuffer[i].vel = float2( 0, 0 );
        }
        outCellBuffer[i].vel = inCellBuffer[i].vel;                  
        outCellBuffer[i].force = inCellBuffer[i].force;               
	    outCellBuffer[i].pos = inCellBuffer[i].pos;                      
    }
    else
    {
        outCellBuffer[i].force = inCellBuffer[i].force;
        outCellBuffer[i].mass = inCellBuffer[i].mass;
        outCellBuffer[i].vel = inCellBuffer[i].vel;
	    outCellBuffer[i].pos = inCellBuffer[i].pos;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel InitMassSAT

[numthreads(GROUPSIZE,1,1)]
void InitMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length = width * height; 
        
    if( i < length )
    {
        outMassSATBuffer[i] = inCellBuffer[i].mass;
    }    
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel TransposeMassSAT

[numthreads(GROUPSIZE,1,1)]
void TransposeMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    if( i < width*height )
    {
        int y = i / width;
        int x = i - y * width;
        int j = x * height + y; 
    
        outMassSATBuffer[i] = inMassSATBuffer[j];
    }    
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeMassSAT

[numthreads(GROUPSIZE,1,1)]
void ComputeMassSAT(uint3 id : SV_DispatchThreadID)
{
    int y = int(id.x);
    
    if (y < height)
    {
        int index = y*width;
        float accumulatedMass = inMassSATBuffer[index]; 
        outMassSATBuffer[index] = accumulatedMass;        
        index++;
         
        for( int x=1; x<width; x++, index++)
        {
            accumulatedMass += inMassSATBuffer[index];
            outMassSATBuffer[index] = accumulatedMass;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeRowStats

[numthreads(GROUPSIZE,1,1)]
void ComputeRowStats(uint3 id : SV_DispatchThreadID)
{
    int y = int(id.x);
    
    if (y < height)
    {
        RowStats rowStats; 
    
        int index = y*width;
        rowStats.maxMass = inCellBuffer[index].mass;
        rowStats.maxVel = length( inCellBuffer[index].vel );       
        index++;

        for( int x=1; x<width; x++, index++)
        {
            rowStats.maxMass = max( rowStats.maxMass, inCellBuffer[index].mass );
            rowStats.maxVel = max( rowStats.maxVel, length( inCellBuffer[index].vel ) );
        }
        
        outRowStatsBuffer[y] = rowStats;        
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMassSAT

[numthreads(GROUPSIZE,1,1)]
void DrawMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float Mass0 = 1;
        const float Mass1 = 10;
        const float Mass2 = 100;
        const float Mass3 = 1000;
        const float Mass4 = 10000;
        
        if( inOutMassSATBuffer[i] < Mass0 )
        {
            renderTexture[xy] = lerp( half4(0,0,0,1), half4(0,0,1,1), inOutMassSATBuffer[i] / Mass0 );   
        } 
        else if( inOutMassSATBuffer[i] < Mass1 )
        {
            renderTexture[xy] = lerp( half4(0,0,1,1), half4(0,1,0,1), (inOutMassSATBuffer[i]-Mass0) / (Mass1-Mass0) );
        }
        else if( inOutMassSATBuffer[i] < Mass2 )
        {
            renderTexture[xy] = lerp( half4(0,1,0,1), half4(1,1,0,1), (inOutMassSATBuffer[i]-Mass1) / (Mass2-Mass1) );
        }
        else if( inOutMassSATBuffer[i] < Mass3 )
        {
            renderTexture[xy] = lerp( half4(1,1,0,1), half4(1,0,0,1), (inOutMassSATBuffer[i]-Mass2) / (Mass3-Mass2) );
        }
        else
        {
            renderTexture[xy] = lerp( half4(1,0,0,1), half4(1,1,1,1), (inOutMassSATBuffer[i]-Mass3) / (Mass4-Mass3) );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMasses

[numthreads(GROUPSIZE,1,1)]
void DrawMasses(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float Mass0 = 0.001;
        const float Mass1 = 0.01;
        const float Mass2 = 0.1;
        const float Mass3 = 1;
        const float Mass4 = 10;
        
        if( inOutCellBuffer[i].mass < Mass0 )
        {
            renderTexture[xy] = lerp( half4(0,0,0,1), half4(0,0,1,1), inOutCellBuffer[i].mass / Mass0 );   
        } 
        else if( inOutCellBuffer[i].mass < Mass1 )
        {
            renderTexture[xy] = lerp( half4(0,0,1,1), half4(0,1,0,1), (inOutCellBuffer[i].mass-Mass0) / (Mass1-Mass0) );
        }
        else if( inOutCellBuffer[i].mass < Mass2 )
        {
            renderTexture[xy] = lerp( half4(0,1,0,1), half4(1,1,0,1), (inOutCellBuffer[i].mass-Mass1) / (Mass2-Mass1) );
        }
        else if( inOutCellBuffer[i].mass < Mass3 )
        {
            renderTexture[xy] = lerp( half4(1,1,0,1), half4(1,0,0,1), (inOutCellBuffer[i].mass-Mass2) / (Mass3-Mass2) );
        }
        else
        {
            renderTexture[xy] = lerp( half4(1,0,0,1), half4(1,1,1,1), (inOutCellBuffer[i].mass-Mass3) / (Mass4-Mass3) );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMomentums

[numthreads(GROUPSIZE,1,1)]
void DrawMomentums(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float VelocityScale = 10.0;
       
        float2 vel = inOutCellBuffer[i].vel;
        float mag = length(vel);
        vel = normalize(vel);
               
        //vel = ( vel + 1.0 ) * 0.5;
        //vel *= saturate( mag / VelocityScale );
        //vel *= sign( inOutCellBuffer[i].mass );
        
        float hue = Angle360( vel, float2(1,0) ) / 360;
        float value = saturate( mag / VelocityScale );
        
        const float Mass0 = 0.0f;
        const float Mul0 = 0.0f;
        const float Mass1 = 0.1f;
        const float Mul1 = 1.0f;
        float factor = saturate( ( inOutCellBuffer[i].mass - Mass0 ) / ( Mass1 - Mass0 ) );
        //vel *= lerp( Mul0, Mul1, factor );
        value *= factor;      
       
        //renderTexture[xy] = half4( vel, 0, 1 );
        renderTexture[xy] = half4( HSV2RGB( float3(hue,1,value) ), 1 );           
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawForces

[numthreads(GROUPSIZE,1,1)]
void DrawForces(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float ForceScale = 0.01;
       
        float2 force = inOutCellBuffer[i].force;
        float mag = length(force);
        force = normalize(force);
        
        float hue = Angle360( force, float2(1,0) ) / 360;
        float value = saturate( mag / ForceScale );                 
               
        //force = ( force + 1.0 ) * 0.5;
        //force *= saturate( mag / ForceScale );
        //force *= sign( inOutCellBuffer[i].mass );
        
        const float Mass0 = 0.0f;
        const float Mul0 = 0.0f;
        const float Mass1 = 0.05f;
        const float Mul1 = 1.0f;
        float factor = saturate( ( inOutCellBuffer[i].mass - Mass0 ) / ( Mass1 - Mass0 ) );
        //force *= lerp( Mul0, Mul1, factor );
        value *= factor;
       
        //renderTexture[xy] = half4( force, 0, 1 );           
        renderTexture[xy] = half4( HSV2RGB( float3(hue,1,value) ), 1 );
    }
}