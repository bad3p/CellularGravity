
#define GROUPSIZE 128

#define MAX_MASS_PROPAGATION_INDICES 9

#define EPSILON 5.96e-08

//////////////////////////////////////////////////////////////////////////////////////

struct Cell
{
    float  mass;
	float2 vel;		
	float2 force;
};

struct RowStats
{
    float maxMass;
    float maxVel;
    float totalMass;
};

struct MassPropagation
{
	int count;
	int indices[MAX_MASS_PROPAGATION_INDICES];	
};

RWStructuredBuffer<Cell> inCellBuffer;
RWStructuredBuffer<Cell> outCellBuffer;
RWStructuredBuffer<Cell> inOutCellBuffer;
RWStructuredBuffer<RowStats> outRowStatsBuffer;
RWStructuredBuffer<float> inMassSATBuffer;
RWStructuredBuffer<float> outMassSATBuffer;
RWStructuredBuffer<float> inOutMassSATBuffer;
RWStructuredBuffer<float4> inOutCellRectBuffer;
RWStructuredBuffer<MassPropagation> inOutMassPropagationBuffer;
RWTexture2D<half4> renderTexture; 

float gravity;
float cellSize;
float cellArea;
float deltaTime;
float density;
int width;
int height;

//////////////////////////////////////////////////////////////////////////////////////

float CellOffsetArea(float2 pos, float2 offset)
{
    float cellExtents = cellSize / 2;

    float infX = pos.x - cellExtents;
    float infY = pos.y - cellExtents;
    float supX = pos.x + cellExtents;
    float supY = pos.y + cellExtents;
        
    return (supX - infX) * abs(offset.y) + (supY - infY) * abs(offset.x) - abs(offset.x * offset.y);
}
    
float CellOverlappingArea(float2 pos0, float2 pos1, float cellSize)
{
    float cellExtents = cellSize / 2;
        
    float left1 = pos0.x - cellExtents;
    float right1 = pos0.x + cellExtents;
    float top1 = pos0.y + cellExtents;
    float bottom1 = pos0.y - cellExtents;
		
    float left2 = pos1.x - cellExtents;
    float right2 = pos1.x + cellExtents;
    float top2 = pos1.y + cellExtents;
    float bottom2 = pos1.y - cellExtents;
		
    float xOverlap = max(0, min(right1, right2) - max(left1, left2));
    float yOverlap = max(0, min(top1, top2) - max(bottom1, bottom2));
    return xOverlap * yOverlap;
 }
 
float CellOverlappingArea(float2 pos0, float2 pos1, float cellSize0, float cellSize1)
{
    float cellExtents0 = cellSize0 / 2;
    float cellExtents1 = cellSize1 / 2;
        
    float left1 = pos0.x - cellExtents0;
    float right1 = pos0.x + cellExtents0;
    float top1 = pos0.y + cellExtents0;
    float bottom1 = pos0.y - cellExtents0;
		
    float left2 = pos1.x - cellExtents1;
    float right2 = pos1.x + cellExtents1;
    float top2 = pos1.y + cellExtents1;
    float bottom2 = pos1.y - cellExtents1;
		
    float xOverlap = max(0, min(right1, right2) - max(left1, left2));
    float yOverlap = max(0, min(top1, top2) - max(bottom1, bottom2));
    return xOverlap * yOverlap;
 } 
 
 float2 GravityForce(float2 p0, float m0, float2 p1, float m1)
 {
    float2 dir = p1 - p0;
    float r = length(dir);
    if (r > EPSILON )
    {
        dir *= 1.0f / r;
        return dir * (m0 * m1 * gravity / ( r * r ));
    }
    else
    {
        return float2( 0, 0 );
    } 
}

float Angle(float2 from, float2 to)
{
    float fromSqrMag = from.x*from.x + from.y*from.y;
    float toSqrMag = to.x*to.x + to.y*to.y;

    float num = sqrt( fromSqrMag * toSqrMag);
    if ( num < 5.96E-08 )
    {
        return 0.0f;
    }
    return acos( clamp( dot(from, to) / num, -1.0, 1.0) ) * 57.29578;
}

float Angle360(float2 from, float2 to)
{
    float signedAngle = Angle(from, to) * sign( from.x * to.y - from.y * to.x);
    if( signedAngle < 0 )
    {
        return 360 + signedAngle;
    }
    else
    {
        return signedAngle;
    }
}

float3 HSV2RGB(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

half4 DrawLegend(int x, int y, float legendScale, half4 pixelValue)
{
    float2 uv = float2( x * 1.0 / width, y * 1.0 / height );
    if( uv.x < legendScale && uv.y < legendScale )
    {
        float2 uvc = float2( legendScale/2, legendScale/2 );
        float2 duv = uv - uvc;
        float duvMag = length(duv);
        duv = normalize(duv);
        if( duvMag <= legendScale/2 )
        {
            float hue = Angle360( duv, float2(1,0) ) / 360;
            float value = duvMag / (legendScale/2);
            float sqrtValue = sqrt(value);
            float easing = smoothstep( 0.5, 0.6, value ) * ( 1.0 - smoothstep( 0.9, 1.0, value ) );
                
            return lerp( pixelValue, half4( HSV2RGB( float3(hue,1,sqrtValue) ), 1 ), value * easing ); 
        }
        else
        {
            return pixelValue;
        }   
    }
    else
    {
        return pixelValue;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeGravityForceWithSAT

[numthreads(GROUPSIZE,1,1)]
void ComputeGravityForceWithSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width * height;
    
    if( i < length0 )
    {     
        int width0 = width;
        int height0 = height;
                     
        int y0 = i / width0;
        int x0 = i - y0 * width0;

        float2 p0 = float2( x0 * cellSize + cellSize / 2, y0 * cellSize + cellSize / 2 );
        float m0 = inOutCellBuffer[i].mass;

        float2 force = float2( 0, 0 );
                        
        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++)
            {
                if ( !(dy0 == 0 && dx0 == 0) )
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                        
                    if (x1 >= 0 && x1 < width0 && y1 >= 0 && y1 < height0)
                    {
                        int j = y1 * width0 + x1;
                        
                        float2 p1 = float2( x1 * cellSize + cellSize / 2, y1 * cellSize + cellSize / 2 );
                        float m1 = inOutCellBuffer[j].mass;
                        force += GravityForce( p0, m0, p1, m1 );
                    }                        
                }
            }
        }
                
        int offset = 3;
        int maxOffset = max(width,height);                
        while( offset <= maxOffset )
        {
            int halfOffset = offset / 2;
        
            for (int dy0 = -1; dy0 <= 1; dy0++)
            {
                for (int dx0 = -1; dx0 <= 1; dx0++)
                {
                    if ( !(dy0 == 0 && dx0 == 0) )
                    {
                        int y1 = y0 + dy0 * offset;
                        int x1 = x0 + dx0 * offset;
                        
                        int yMin = max( 0, y1 - halfOffset - 1 );
                        int xMin = max( 0, x1 - halfOffset - 1 );                        
                        int yMax = min( height0 - 1, y1 + halfOffset );
                        int xMax = min( width0 - 1, x1 + halfOffset );
                        
                        if( yMin <= yMax && xMin <= xMax )
                        {
                            int iMinMin = yMin * width0 + xMin;
                            int iMaxMin = yMin * width0 + xMax;
                            int iMaxMax = yMax * width0 + xMax;
                            int iMinMax = yMax * width0 + xMin;
                            
                            float lx = xMin * cellSize + cellSize / 2;
                            float rx = xMax * cellSize + cellSize / 2;
                            float ty = yMin * cellSize + cellSize / 2;
                            float by = yMax * cellSize + cellSize / 2;
                            
                            float2 virtualCellPos = ( float2(lx,ty) +
                                                      float2(rx,ty) +
                                                      float2(rx,by) +
                                                      float2(lx,by) ) / 4;
                                                 
                            virtualCellPos += float2( cellSize/2, cellSize/2 );                                                 
                                                    
                            float2 virtualCellMass = inOutMassSATBuffer[iMaxMax] -
                                                     inOutMassSATBuffer[iMinMax] -                                                     
                                                     inOutMassSATBuffer[iMaxMin] +
                                                     inOutMassSATBuffer[iMinMin];
                                                     
                            force += GravityForce( p0, m0, virtualCellPos, virtualCellMass );                                                   
                        }
                    }
                }
            }
            
            offset *= 3;
        }
                
        inOutCellBuffer[i].force = force;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel IntegrateVelocity

[numthreads(GROUPSIZE,1,1)]
void IntegrateVelocity(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);  
    
    if( i < width*height )
    {    
        if (inOutCellBuffer[i].mass > EPSILON)
        {
            inOutCellBuffer[i].vel += inOutCellBuffer[i].force / inOutCellBuffer[i].mass * deltaTime; 
        }
        else
        {
            inOutCellBuffer[i].vel = float2( 0, 0 ); 
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel CleanupMassPropagationBuffer

[numthreads(GROUPSIZE,1,1)]
void CleanupMassPropagationBuffer(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);  
    
    if( i < width*height )
    {    
        inOutMassPropagationBuffer[i].count = 0;
        for( int j=0; j<MAX_MASS_PROPAGATION_INDICES; j++ )
        {
            inOutMassPropagationBuffer[i].indices[j] = 0;
        }        
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel MassPropagationPrepass

[numthreads(GROUPSIZE,1,1)]
void MassPropagationPrepass(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);  
    
    if( i < width*height )
    {
        int y = i / width;
        int x = i - y * width;
        
        float cellExtents = float2( cellSize, cellSize );
        float cellHalfExtents = cellExtents / 2;
        
        float2 cellOffset = inCellBuffer[i].vel * deltaTime; 
        float2 cellPos = float2( x, y ) * cellSize + cellHalfExtents + cellOffset;
        float4 cellRect = float4( cellPos - cellHalfExtents, cellPos + cellHalfExtents );
        
        float expansionVel = inCellBuffer[i].mass * density / (cellSize*cellSize);         
        float expansion = ( expansionVel * deltaTime ) / 2;
        cellRect += float4( -expansion, -expansion, expansion, expansion );
        
        inOutCellRectBuffer[i] = cellRect;
        
        int2 xyInf = floor( cellRect.xy / cellSize );
        int2 xySup = floor( cellRect.zw / cellSize );
        
        for (int y1 = xyInf.y; y1 <= xySup.y; y1++)
        {
            for (int x1 = xyInf.x; x1 <= xySup.x; x1++)
            {
                int j = y1 * width + x1;
                
                int writeIndex;
                InterlockedAdd( inOutMassPropagationBuffer[j].count, 1, writeIndex );
                if( writeIndex < MAX_MASS_PROPAGATION_INDICES )
                {
                    inOutMassPropagationBuffer[j].indices[writeIndex] = i;
                }
            }
        }                   
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel MassPropagationPass

float4 IntersectRects(float4 rect1, float4 rect2)  
{
    float xInf1 = rect1.x;
    float yInf1 = rect1.y;
    float xSup1 = rect1.z;
    float ySup1 = rect1.w;
    float xInf2 = rect2.x;
    float yInf2 = rect2.y;
    float xSup2 = rect2.z;
    float ySup2 = rect2.w;
        
    return float4
    (
        min( max( xInf1, xInf2 ), xSup2 ),
        min( max( yInf1, yInf2 ), ySup2 ),
        max( min( xSup1, xSup2 ), xInf2 ),
        max( min( ySup1, ySup2 ), yInf2 )
    );
}

float RectArea(float4 rect)
{
    return (rect.z-rect.x)*(rect.w-rect.y);
}

[numthreads(GROUPSIZE,1,1)]
void MassPropagationPass(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);  
    
    if( i < width*height )
    {
        int y = i / width;
        int x = i - y * width;
        
        float cellExtents = float2( cellSize, cellSize );
        float cellHalfExtents = cellExtents / 2;
        
        float2 cellPos = float2( x, y ) * cellSize + cellHalfExtents;
        float4 cellRect = float4( cellPos - cellHalfExtents, cellPos + cellHalfExtents );
        
        float cellMass = 0;
        float2 cellMassVel = float2( 0, 0 ); 
        
        int count = min( inOutMassPropagationBuffer[i].count, MAX_MASS_PROPAGATION_INDICES );
        for (int j = 0; j <= count; j++)
        {
            int k = inOutMassPropagationBuffer[i].indices[j];            
            
            float4 otherCellRect = inOutCellRectBuffer[k];            
            float4 intersectionRect = IntersectRects( cellRect, otherCellRect );
            float intersectionRectArea = RectArea( intersectionRect );
            
            if( intersectionRectArea > EPSILON )
            {            
                float otherCellRectArea = RectArea( otherCellRect );
                float intersectionRectAreaRatio = intersectionRectArea / otherCellRectArea;
                float deltaMass = intersectionRectAreaRatio * inCellBuffer[k].mass;
                cellMass += deltaMass;
                cellMassVel += deltaMass * inCellBuffer[k].vel;
            } 
        }
        
        if( cellMass > EPSILON && i != 0 ) 
        {
            outCellBuffer[i].mass = cellMass;
            outCellBuffer[i].vel = cellMassVel / cellMass;
        }
        else
        {
            outCellBuffer[i].mass = 0;
            outCellBuffer[i].vel = float2( 0, 0 );
        }
        outCellBuffer[i].force = inCellBuffer[i].force; 
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel MomentumTransfer

[numthreads(GROUPSIZE,1,1)]
void MomentumTransfer(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width*height; 
        
    if( i < length0 )
    {        
        float cellArea = cellSize * cellSize;
        
        int y0 = i / width;
        int x0 = i - y0 * width;
 
        outCellBuffer[i].force = inCellBuffer[i].force;

        float2 iPos = float2( x0 * cellSize + cellSize / 2, y0 * cellSize + cellSize / 2 );
        float2 iOffset = inCellBuffer[i].vel * deltaTime;
        float offsetAreaRatio = CellOffsetArea( iPos, iOffset) / cellArea;
        outCellBuffer[i].mass = inCellBuffer[i].mass - inCellBuffer[i].mass * offsetAreaRatio;
        
        if (outCellBuffer[i].mass < EPSILON)
        {
            outCellBuffer[i].mass = 0;
        }
                    
        outCellBuffer[i].vel = inCellBuffer[i].vel * outCellBuffer[i].mass;      

        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++)
            {
                if (!(dy0 == 0 && dx0 == 0))
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                    
                    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height)
                    {
                        int j = y1 * width + x1;

                        float2 jPos = float2( x1 * cellSize + cellSize / 2, y1 * cellSize + cellSize / 2 );                    
                        float2 jOffset = inCellBuffer[j].vel * deltaTime;
                        float overlappingArea = CellOverlappingArea( iPos, jPos + jOffset, cellSize);
                        if (overlappingArea > EPSILON)
                        {
                            float overlappingAreaRatio = overlappingArea / cellArea;                             
                            float dm = inCellBuffer[j].mass * overlappingAreaRatio;                            
                            outCellBuffer[i].mass += dm;
                            outCellBuffer[i].vel += inCellBuffer[j].vel * dm;                                
                        }                        
                    }
                }
            }
        }
            
        if (outCellBuffer[i].mass > EPSILON )
        {
            outCellBuffer[i].vel = outCellBuffer[i].vel / outCellBuffer[i].mass;              
        }
        else
        {
            outCellBuffer[i].vel = float2( 0, 0 );
        }
    }
    else
    {
        outCellBuffer[i].force = inCellBuffer[i].force;
        outCellBuffer[i].mass = inCellBuffer[i].mass;
        outCellBuffer[i].vel = inCellBuffer[i].vel;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel LocalExpansion

[numthreads(GROUPSIZE,1,1)]
void LocalExpansion(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length0 = width*height; 
        
    if( i < length0 )
    {
        float cellArea = cellSize * cellSize;
        
        int y0 = i / width;
        int x0 = i - y0 * width;
        
        float expansionVel = inCellBuffer[i].mass * density / cellArea;         
        float expandedCellSize = cellSize + expansionVel * deltaTime;
        float expandedCellArea = expandedCellSize * expandedCellSize;
        
        outCellBuffer[i].mass = inCellBuffer[i].mass * cellArea / expandedCellArea;
        outCellBuffer[i].vel = inCellBuffer[i].vel * outCellBuffer[i].mass;
        
        float2 iPos = float2( x0 * cellSize + cellSize / 2, y0 * cellSize + cellSize / 2 );  
        
        for (int dy0 = -1; dy0 <= 1; dy0++)
        {
            for (int dx0 = -1; dx0 <= 1; dx0++) 
            {
                if (!(dy0 == 0 && dx0 == 0))
                {
                    int y1 = y0 + dy0;
                    int x1 = x0 + dx0;
                    
                    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height)
                    {
                        int j = y1 * width + x1;
                        
                        expansionVel = inCellBuffer[j].mass * density / cellArea;         
                        expandedCellSize = cellSize + expansionVel * deltaTime;
                        expandedCellArea = expandedCellSize * expandedCellSize;

                        float2 jPos = float2( x1 * cellSize + cellSize / 2, y1 * cellSize + cellSize / 2 );                        
                        float overlappingArea = CellOverlappingArea( iPos, jPos, cellSize, expandedCellSize);
                        if( overlappingArea > EPSILON )
                        {
                            float overlappingAreaRatio = overlappingArea / expandedCellArea;
                            float dm = inCellBuffer[j].mass * overlappingAreaRatio;
                            outCellBuffer[i].mass += dm;
                            float2 expVel = outCellBuffer[j].vel;// + normalize( iPos - jPos ) * expansionVel;
                            outCellBuffer[i].vel += expVel * dm;     
                        }
                    }
                }
            }
        }
        
        if (outCellBuffer[i].mass > EPSILON )
        {
            outCellBuffer[i].vel = outCellBuffer[i].vel / outCellBuffer[i].mass;              
        }
        else
        {
            outCellBuffer[i].vel = float2( 0, 0 );
        }
        outCellBuffer[i].vel = inCellBuffer[i].vel;                  
        outCellBuffer[i].force = inCellBuffer[i].force;                                    
    }
    else
    {
        outCellBuffer[i].force = inCellBuffer[i].force;
        outCellBuffer[i].mass = inCellBuffer[i].mass;
        outCellBuffer[i].vel = inCellBuffer[i].vel;
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel InitMassSAT

[numthreads(GROUPSIZE,1,1)]
void InitMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    int length = width * height; 
        
    if( i < length )
    {
        outMassSATBuffer[i] = inCellBuffer[i].mass;
    }    
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel TransposeMassSAT

[numthreads(GROUPSIZE,1,1)]
void TransposeMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
    
    if( i < width*height )
    {
        int y = i / width;
        int x = i - y * width;
        int j = x * height + y; 
    
        outMassSATBuffer[i] = inMassSATBuffer[j];
    }    
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeMassSAT

[numthreads(GROUPSIZE,1,1)]
void ComputeMassSAT(uint3 id : SV_DispatchThreadID)
{
    int y = int(id.x);
    
    if (y < height)
    {
        int index = y*width;
        float accumulatedMass = inMassSATBuffer[index]; 
        outMassSATBuffer[index] = accumulatedMass;        
        index++;
         
        for( int x=1; x<width; x++, index++)
        {
            accumulatedMass += inMassSATBuffer[index];
            outMassSATBuffer[index] = accumulatedMass;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel ComputeRowStats

[numthreads(GROUPSIZE,1,1)]
void ComputeRowStats(uint3 id : SV_DispatchThreadID)
{
    int y = int(id.x);
    
    if (y < height)
    {
        RowStats rowStats; 
    
        int index = y*width;
        rowStats.maxMass = inCellBuffer[index].mass;
        rowStats.maxVel = length( inCellBuffer[index].vel );
        rowStats.totalMass = inCellBuffer[index].mass;
        index++;

        for( int x=1; x<width; x++, index++)
        {
            rowStats.maxMass = max( rowStats.maxMass, inCellBuffer[index].mass );
            rowStats.maxVel = max( rowStats.maxVel, length( inCellBuffer[index].vel ) );
            rowStats.totalMass += inCellBuffer[index].mass;
        }
        
        outRowStatsBuffer[y] = rowStats;        
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMassSAT

[numthreads(GROUPSIZE,1,1)]
void DrawMassSAT(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float Mass0 = 1;
        const float Mass1 = 10;
        const float Mass2 = 100;
        const float Mass3 = 1000;
        const float Mass4 = 10000;
        
        if( inOutMassSATBuffer[i] < Mass0 )
        {
            renderTexture[xy] = lerp( half4(0,0,0,1), half4(0,0,1,1), inOutMassSATBuffer[i] / Mass0 );   
        } 
        else if( inOutMassSATBuffer[i] < Mass1 )
        {
            renderTexture[xy] = lerp( half4(0,0,1,1), half4(0,1,0,1), (inOutMassSATBuffer[i]-Mass0) / (Mass1-Mass0) );
        }
        else if( inOutMassSATBuffer[i] < Mass2 )
        {
            renderTexture[xy] = lerp( half4(0,1,0,1), half4(1,1,0,1), (inOutMassSATBuffer[i]-Mass1) / (Mass2-Mass1) );
        }
        else if( inOutMassSATBuffer[i] < Mass3 )
        {
            renderTexture[xy] = lerp( half4(1,1,0,1), half4(1,0,0,1), (inOutMassSATBuffer[i]-Mass2) / (Mass3-Mass2) );
        }
        else
        {
            renderTexture[xy] = lerp( half4(1,0,0,1), half4(1,1,1,1), (inOutMassSATBuffer[i]-Mass3) / (Mass4-Mass3) );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMasses

[numthreads(GROUPSIZE,1,1)]
void DrawMasses(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float Mass0 = 0.001;
        const float Mass1 = 0.01;
        const float Mass2 = 0.1;
        const float Mass3 = 1;
        const float Mass4 = 10;
        
        if( inOutCellBuffer[i].mass < Mass0 )
        {
            renderTexture[xy] = lerp( half4(0,0,0,1), half4(0,0,1,1), inOutCellBuffer[i].mass / Mass0 );   
        } 
        else if( inOutCellBuffer[i].mass < Mass1 )
        {
            renderTexture[xy] = lerp( half4(0,0,1,1), half4(0,1,0,1), (inOutCellBuffer[i].mass-Mass0) / (Mass1-Mass0) );
        }
        else if( inOutCellBuffer[i].mass < Mass2 )
        {
            renderTexture[xy] = lerp( half4(0,1,0,1), half4(1,1,0,1), (inOutCellBuffer[i].mass-Mass1) / (Mass2-Mass1) );
        }
        else if( inOutCellBuffer[i].mass < Mass3 )
        {
            renderTexture[xy] = lerp( half4(1,1,0,1), half4(1,0,0,1), (inOutCellBuffer[i].mass-Mass2) / (Mass3-Mass2) );
        }
        else
        {
            renderTexture[xy] = lerp( half4(1,0,0,1), half4(1,1,1,1), (inOutCellBuffer[i].mass-Mass3) / (Mass4-Mass3) );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawMomentums

[numthreads(GROUPSIZE,1,1)]
void DrawMomentums(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float VelocityScale = 10.0;
       
        float2 vel = inOutCellBuffer[i].vel;
        float mag = length(vel);
        vel = normalize(vel);
               
        //vel = ( vel + 1.0 ) * 0.5;
        //vel *= saturate( mag / VelocityScale );
        //vel *= sign( inOutCellBuffer[i].mass );
        
        float hue = Angle360( vel, float2(1,0) ) / 360;
        float value = saturate( mag / VelocityScale );
        
        const float Mass0 = 0.0f;
        const float Mul0 = 0.0f;
        const float Mass1 = 0.1f;
        const float Mul1 = 1.0f;
        float factor = saturate( ( inOutCellBuffer[i].mass - Mass0 ) / ( Mass1 - Mass0 ) );
        //vel *= lerp( Mul0, Mul1, factor );
        value *= factor;      
       
        //renderTexture[xy] = half4( vel, 0, 1 );
        renderTexture[xy] = half4( HSV2RGB( float3(hue,1,value) ), 1 );
        
        // legend        
        const float LegendScale = 0.25f;        
        renderTexture[xy] = DrawLegend( x, y, LegendScale, renderTexture[xy] );           
    }
}

//////////////////////////////////////////////////////////////////////////////////////

#pragma kernel DrawForces

[numthreads(GROUPSIZE,1,1)]
void DrawForces(uint3 id : SV_DispatchThreadID)
{
    int i = int(id.x);
        
    if( i < width*height )
    {        
        int y = i / width;
        int x = i - y * width;        
        
        int2 xy = int2( x,y );
        
        const float ForceScale = 0.01;
       
        float2 force = inOutCellBuffer[i].force;
        float mag = length(force);
        force = normalize(force);
        
        float hue = Angle360( force, float2(1,0) ) / 360;
        float value = saturate( mag / ForceScale );                 
               
        //force = ( force + 1.0 ) * 0.5;
        //force *= saturate( mag / ForceScale );
        //force *= sign( inOutCellBuffer[i].mass );
        
        const float Mass0 = 0.0f;
        const float Mul0 = 0.0f;
        const float Mass1 = 0.05f;
        const float Mul1 = 1.0f;
        float factor = saturate( ( inOutCellBuffer[i].mass - Mass0 ) / ( Mass1 - Mass0 ) );
        //force *= lerp( Mul0, Mul1, factor );
        value *= factor;
       
        //renderTexture[xy] = half4( force, 0, 1 );           
        renderTexture[xy] = half4( HSV2RGB( float3(hue,1,value) ), 1 );
        
        // legend        
        const float LegendScale = 0.25f;        
        renderTexture[xy] = DrawLegend( x, y, LegendScale, renderTexture[xy] );
    }
}